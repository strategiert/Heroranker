import { createClient } from '@supabase/supabase-js';
import { ExternalHero } from '../types';

// Safe environment access for browser environments
const getEnv = (key: string) => {
  try {
    // @ts-ignore
    if (typeof process !== 'undefined' && process.env) return process.env[key];
  } catch (e) { }
  return '';
};

// Initialize Supabase Client using the Service Role Key to ensure access (Bypass RLS)
const supabaseUrl = getEnv('SUPABASE_URL') || 'https://uwzmldtoiulcezexsclo.supabase.co';
const supabaseKey = getEnv('SUPABASE_KEY') || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InV3em1sZHRvaXVsY2V6ZXhzY2xvIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc2Njg1NDE1OSwiZXhwIjoyMDgyNDMwMTU5fQ.NjD8tZ933Uba4ii3XxOEbNFa7atwrON80GlKpe6nmS0';

export const supabase = createClient(supabaseUrl, supabaseKey, {
  auth: {
    persistSession: false,
    autoRefreshToken: false,
    detectSessionInUrl: false
  }
});

export const REQUIRED_TABLE_NAME = 'superheroes_raw';

export const SCHEMA_SQL = `
-- Kopiere dies in den Supabase SQL Editor:

CREATE TABLE IF NOT EXISTS "superheroes_raw" (
    id bigint generated by default as identity primary key,
    name text,
    full_name text,
    race text,
    publisher text,
    alignment text,
    intelligence integer,
    strength integer,
    speed integer,
    durability integer,
    power integer,
    combat integer,
    image_url text,
    description text
);
`;

export const listTables = async (): Promise<string[]> => {
  try {
    const { data, error } = await supabase
      .from('information_schema.tables')
      .select('table_name')
      .eq('table_schema', 'public');

    if (error) return [];
    return data ? data.map((row: any) => row.table_name) : [];
  } catch (e) {
    return [];
  }
};

// Robust utility to remove surrounding quotes and 'None' strings
const cleanStr = (val: any): string => {
  if (typeof val !== 'string') return '';
  let cleaned = val.replace(/^['"]+|['"]+$/g, '').trim();
  if (cleaned.toLowerCase() === 'none' || cleaned === '-') return '';
  return cleaned;
};

// Helper to calculate total stats for comparison
const getPowerScore = (h: ExternalHero) => {
    return (h.intelligence || 0) + (h.strength || 0) + (h.speed || 0) + 
           (h.durability || 0) + (h.power || 0) + (h.combat || 0);
};

export const fetchRawHeroes = async (limit = 1000, offset = 0): Promise<ExternalHero[]> => {
  if (!supabaseUrl || !supabaseKey) {
     throw new Error("Supabase Credentials fehlen.");
  }

  const { data, error } = await supabase
    .from(REQUIRED_TABLE_NAME) 
    .select('*')
    .range(offset, offset + limit - 1);

  if (error) {
      if (error.code === 'PGRST205' || error.code === '42P01') {
            throw new Error(`Tabelle '${REQUIRED_TABLE_NAME}' nicht gefunden.`);
      }
      throw error;
  }

  if (!data) return [];

  const processedHeroes: ExternalHero[] = data.map((record: any) => {
    
    const getVal = (keys: string[]) => {
        for(const k of keys) {
            if (record[k] !== undefined && record[k] !== null) return record[k];
            if (record[k.toLowerCase()] !== undefined && record[k.toLowerCase()] !== null) return record[k.toLowerCase()];
        }
        return undefined;
    };

    return {
        name: cleanStr(getVal(['Character', 'character', 'name', 'Name'])) || 'Unknown',
        full_name: cleanStr(getVal(['full_name', 'FullName', 'Real_Name', 'Alter_Egos', 'alter_egos'])) || 'Unknown',
        race: cleanStr(getVal(['race', 'Race', 'Species'])) || 'Unknown',
        publisher: cleanStr(getVal(['publisher', 'Publisher'])) || 'Unknown',
        alignment: cleanStr(getVal(['alignment', 'Alignment'])) || 'neutral',
        
        intelligence: Number(getVal(['intelligence', 'Intelligence'])) || 0,
        strength: Number(getVal(['strength', 'Strength'])) || 0,
        speed: Number(getVal(['speed', 'Speed'])) || 0,
        durability: Number(getVal(['durability', 'Durability'])) || 0,
        power: Number(getVal(['power', 'Power'])) || 0,
        combat: Number(getVal(['combat', 'Combat'])) || 0,
        
        description: cleanStr(getVal(['description', 'Description', 'History'])),
        image: cleanStr(getVal(['image_url', 'image', 'Image', 'url']))
    };
  });

  // SMART DEDUPLICATION
  const uniqueHeroes = new Map<string, ExternalHero>();
  
  processedHeroes.forEach(hero => {
      if (!hero.name || hero.name === 'Unknown') return;

      const existing = uniqueHeroes.get(hero.name);
      
      if (!existing) {
          uniqueHeroes.set(hero.name, hero);
      } else {
          const scoreNew = getPowerScore(hero);
          const scoreExisting = getPowerScore(existing);
          
          if (scoreNew > scoreExisting) {
              uniqueHeroes.set(hero.name, hero);
          } else if (scoreNew === scoreExisting && !existing.image && hero.image) {
              uniqueHeroes.set(hero.name, hero);
          }
      }
  });

  return Array.from(uniqueHeroes.values());
};

export const seedDatabase = async (onProgress?: (msg: string) => void) => {
    console.warn("Seeding disabled by user request.");
    return 0;
};